import 'dart:async';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/notification_model.dart';
import 'auth_provider.dart';

class NotificationProvider with ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  List<AppNotification> _notifications = [];
  int _unreadCount = 0;
  StreamSubscription<QuerySnapshot>? _subscription;
  String? _currentUserId;

  List<AppNotification> get notifications => _notifications;
  int get unreadCount => _unreadCount;

  /// Initialize listener for a specific user
  void init(String userId) {
    if (_currentUserId == userId) return; 
    
    _currentUserId = userId;
    _subscription?.cancel();

    _subscription = _firestore
        .collection('notifications')
        .where('targetUserId', isEqualTo: userId)
        .orderBy('createdAt', descending: true) // Sort by createdAt for stable ordering
        .limit(10) // Limit to last 10 notifications
        .snapshots()
        .listen((snapshot) {
      _notifications = snapshot.docs
          .map((doc) => AppNotification.fromFirestore(doc.data(), doc.id))
          .toList();
      
      // No need to sort in memory since we're ordering in the query
      
      _unreadCount = _notifications.where((n) => !n.isRead).length;
      notifyListeners();
    }, onError: (e) {
      debugPrint('Error listening to notifications: $e');
    });
  }

  /// Stop listening (e.g. on logout)
  void disposeListener() {
    _subscription?.cancel();
    _subscription = null;
    _currentUserId = null;
    _notifications = [];
    _unreadCount = 0;
    notifyListeners(); // Clear UI
  }

  /// Mark a notification as read
  Future<void> markAsRead(String notificationId) async {
    try {
      // Optimistic update
      final index = _notifications.indexWhere((n) => n.id == notificationId);
      if (index != -1 && !_notifications[index].isRead) {
        // Create a copy with isRead = true
        // We can't easily modify the list since it's from the stream, 
        // but the stream update will come shortly.
        // For instant UI feedback we wait for Firestore stream.
        await _firestore.collection('notifications').doc(notificationId).update({
          'isRead': true,
        });
      }
    } catch (e) {
      debugPrint('Error marking notification as read: $e');
    }
  }

  /// Mark all visible notifications as read
  Future<void> markAllAsRead() async {
    try {
      final batch = _firestore.batch();
      final unreadDocs = _notifications.where((n) => !n.isRead);
      
      for (var doc in unreadDocs) {
        final ref = _firestore.collection('notifications').doc(doc.id);
        batch.update(ref, {'isRead': true});
      }
      
      if (unreadDocs.isNotEmpty) {
        await batch.commit();
      }
    } catch (e) {
      debugPrint('Error marking all as read: $e');
    }
  }

  /// Send a ping to a specific user (Admin only)
  Future<void> sendPing({
    required String targetUserId,
    required String title,
    required String body,
    required String senderName,
    required String senderId,
  }) async {
    try {
      final notification = AppNotification(
        id: '', // Generated by Firestore
        targetUserId: targetUserId,
        title: title,
        body: body,
        type: NotificationType.ping,
        createdAt: DateTime.now(),
        senderName: senderName,
        senderId: senderId,
      );

      await _firestore.collection('notifications').add(notification.toFirestore());
    } catch (e) {
      debugPrint('Error sending ping: $e');
      rethrow;
    }
  }

  /// Send a ping to ALL workers (Admin only)
  /// Warning: efficient for small number of workers. For large scale, use Cloud Functions.
  Future<void> sendGlobalPing({
    required String title,
    required String body,
    required String senderName,
    required String senderId,
  }) async {
    try {
      // 1. Get all users with 'worker' role
      final workersSnapshot = await _firestore
          .collection('users')
          .where('role', isEqualTo: 'worker')
          .get();

      final batch = _firestore.batch();

      for (var doc in workersSnapshot.docs) {
        final newDocRef = _firestore.collection('notifications').doc();
        final notification = AppNotification(
          id: newDocRef.id,
          targetUserId: doc.id,
          title: title,
          body: body,
          type: NotificationType.dailyReportRequest,
          createdAt: DateTime.now(),
          senderName: senderName,
          senderId: senderId,
        );
        
        batch.set(newDocRef, notification.toFirestore());
      }

      await batch.commit();
    } catch (e) {
      debugPrint('Error sending global ping: $e');
      rethrow;
    }
  }
}
